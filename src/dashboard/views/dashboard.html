<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Robin MCP — Dashboard</title>
<!-- IBM Plex Sans -->
<link rel="stylesheet" href="https://1.www.s81c.com/common/carbon/plex/sans.css">
<!-- Carbon Themes (g100 dark) -->
<link rel="stylesheet" href="https://1.www.s81c.com/common/carbon/web-components/tag/latest/themes.css">
<!-- Carbon Grid -->
<link rel="stylesheet" href="https://1.www.s81c.com/common/carbon/web-components/tag/latest/grid.css">
<!-- Carbon Charts CSS -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@carbon/charts@1.27.2/dist/styles.min.css">
<!-- Shared styles -->
<link rel="stylesheet" href="/dashboard/assets/shared.css">
<!-- Carbon Web Components -->
<script type="module" src="https://1.www.s81c.com/common/carbon/web-components/tag/v2/latest/tile.min.js"></script>
<script type="module" src="https://1.www.s81c.com/common/carbon/web-components/tag/v2/latest/tag.min.js"></script>
<script type="module" src="https://1.www.s81c.com/common/carbon/web-components/tag/v2/latest/tabs.min.js"></script>
<script type="module" src="https://1.www.s81c.com/common/carbon/web-components/tag/v2/latest/dropdown.min.js"></script>
<script type="module" src="https://1.www.s81c.com/common/carbon/web-components/tag/v2/latest/data-table.min.js"></script>
<!-- D3 (charts peer dep) + Carbon Charts UMD -->
<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script src="https://cdn.jsdelivr.net/npm/@carbon/charts@1.27.2/dist/umd/bundle.umd.js"></script>
<style>
  body {
    background: var(--cds-background, #161616);
  }
  /* Gauge container */
  .gauge-container {
    width: 100%;
    height: 120px;
    position: relative;
    margin-top: 0.25rem;
  }
  /* Override Carbon Charts background for g100 theme */
  .bx--chart-holder,
  .cds--chart-holder {
    background: transparent !important;
  }
</style>
</head>
<body class="cds-theme-zone-g100">
<div class="page-container">

  <!-- Header -->
  <div class="dashboard-header">
    <h1>Robin MCP Dashboard</h1>
    <div class="header-controls">
      <cds-tag type="gray" id="sessions">0 sessions</cds-tag>
      <nav class="nav-tabs">
        <a href="/dashboard" class="nav-tab active">Overview</a>
        <a href="/dashboard/routing" class="nav-tab">Routing</a>
      </nav>
      <cds-dropdown
        id="periodSelect"
        value="7d"
        label="Time period"
        hide-label
        size="sm"
      >
        <cds-dropdown-item value="24h">Last 24h</cds-dropdown-item>
        <cds-dropdown-item value="7d">Last 7 days</cds-dropdown-item>
        <cds-dropdown-item value="30d">Last 30 days</cds-dropdown-item>
        <cds-dropdown-item value="all">All time</cds-dropdown-item>
      </cds-dropdown>
    </div>
  </div>

  <!-- KPI Cards -->
  <div class="cards-grid" id="overviewCards">
    <cds-tile>
      <div class="kpi-label">Total Calls</div>
      <div class="kpi-value" id="totalCalls">&mdash;</div>
    </cds-tile>
    <cds-tile>
      <div class="kpi-label">Success Rate</div>
      <div class="kpi-value" id="successRateValue">&mdash;</div>
      <div class="gauge-container" id="successGauge"></div>
    </cds-tile>
    <cds-tile>
      <div class="kpi-label">Avg Response</div>
      <div class="kpi-value" id="avgDuration">&mdash;</div>
      <div class="kpi-sub">ms</div>
    </cds-tile>
    <cds-tile>
      <div class="kpi-label">Est. Tokens</div>
      <div class="kpi-value" id="estTokens">&mdash;</div>
    </cds-tile>
  </div>

  <!-- Adapter Health -->
  <div class="section-tile">
    <cds-tile>
      <h2 class="section-title">Adapter Health</h2>
      <div class="adapters-grid" id="adapterHealth">
        <p class="empty-state">Loading...</p>
      </div>
    </cds-tile>
  </div>

  <!-- Tool Usage Chart -->
  <div class="section-tile">
    <cds-tile>
      <h2 class="section-title">Tool Usage</h2>
      <div class="chart-container" id="toolChart">
        <p class="empty-state">Loading...</p>
      </div>
    </cds-tile>
  </div>

  <!-- Source Popularity Chart -->
  <div class="section-tile">
    <cds-tile>
      <h2 class="section-title">Source Popularity</h2>
      <div class="chart-container" id="sourceChart">
        <p class="empty-state">Loading...</p>
      </div>
    </cds-tile>
  </div>

  <!-- Source Popularity vs Token Cost Chart -->
  <div class="section-tile">
    <cds-tile>
      <h2 class="section-title">Source Popularity vs Token Cost</h2>
      <div class="chart-container" id="sourceTokenChart">
        <p class="empty-state">Loading...</p>
      </div>
    </cds-tile>
  </div>

  <!-- Recent Calls Table -->
  <div class="section-tile">
    <cds-tile>
      <h2 class="section-title">Recent Calls</h2>
      <div id="recentCallsContainer">
        <cds-table>
          <cds-table-head>
            <cds-table-header-row>
              <cds-table-header-cell>Tool</cds-table-header-cell>
              <cds-table-header-cell>Source</cds-table-header-cell>
              <cds-table-header-cell>Status</cds-table-header-cell>
              <cds-table-header-cell>Duration</cds-table-header-cell>
              <cds-table-header-cell>Tokens</cds-table-header-cell>
              <cds-table-header-cell>Time</cds-table-header-cell>
            </cds-table-header-row>
          </cds-table-head>
          <cds-table-body id="recentCalls">
            <cds-table-row>
              <cds-table-cell colspan="6"><span class="empty-state">Loading...</span></cds-table-cell>
            </cds-table-row>
          </cds-table-body>
        </cds-table>
      </div>
    </cds-tile>
  </div>

  <div class="refresh-note">Auto-refreshes every 30s</div>

</div>

<script>
const API = '/dashboard/api';
let period = '7d';
const chartInstances = new Map();

function fmt(n) {
  if (n == null) return '\u2014';
  if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
  if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
  return String(n);
}

function relTime(iso) {
  if (!iso) return '\u2014';
  const d = new Date(iso + 'Z');
  const diff = (Date.now() - d.getTime()) / 1000;
  if (diff < 60) return Math.round(diff) + 's ago';
  if (diff < 3600) return Math.round(diff / 60) + 'm ago';
  if (diff < 86400) return Math.round(diff / 3600) + 'h ago';
  return Math.round(diff / 86400) + 'd ago';
}

async function fetchJson(url) {
  const res = await fetch(url);
  if (!res.ok) throw new Error(res.statusText);
  return res.json();
}

function destroyChart(key) {
  if (chartInstances.has(key)) {
    try { chartInstances.get(key).destroy(); } catch {}
    chartInstances.delete(key);
  }
}

function destroyAllCharts() {
  for (const key of chartInstances.keys()) {
    destroyChart(key);
  }
}

// Replace a chart container with a fresh DOM node — removes all
// residual state (ResizeObservers, inline styles, event listeners)
function freshContainer(id) {
  const old = document.getElementById(id);
  if (!old) return;
  const el = document.createElement('div');
  el.id = old.id;
  el.className = old.className;
  old.parentNode.replaceChild(el, old);
}

async function loadStats() {
  const data = await fetchJson(API + '/stats?period=' + period);

  // Update text KPIs regardless of visibility
  document.getElementById('totalCalls').textContent = fmt(data.totalCalls);
  document.getElementById('avgDuration').textContent = fmt(data.avgDurationMs);
  document.getElementById('estTokens').textContent = fmt(data.estimatedTokens);

  const successRate = data.successRate != null ? data.successRate : 0;
  document.getElementById('successRateValue').textContent = successRate + '%';

  // Skip chart rendering if tab went hidden during fetch
  if (document.hidden) return;

  // Gauge chart for success rate
  renderGauge(successRate);

  // Tool usage bar chart
  renderToolChart(data.topTools || []);

  // Source popularity donut chart
  renderSourceChart(data.sourceBreakdown || []);

  // Source popularity vs token cost grouped bar chart
  renderSourceTokenChart(data.sourceBreakdown || []);
}

function renderGauge(rate) {
  const container = document.getElementById('successGauge');
  destroyChart('gauge');
  container.innerHTML = '';

  if (rate == null) return;

  let status;
  if (rate >= 95) status = 'success';
  else if (rate >= 80) status = 'warning';
  else status = 'danger';

  try {
    const chart = new Charts.GaugeChart(container, {
      data: [{ group: 'value', value: rate }],
      options: {
        theme: 'g100',
        resizable: true,
        height: '120px',
        gauge: {
          type: 'semi',
          status: status
        },
        color: {
          scale: {
            value: rate >= 95 ? '#42be65' : rate >= 80 ? '#f1c21b' : '#fa4d56'
          }
        },
        legend: { enabled: false },
        toolbar: { enabled: false }
      }
    });
    chartInstances.set('gauge', chart);
  } catch (e) {
    container.innerHTML = '<span style="color:' +
      (rate >= 95 ? '#42be65' : rate >= 80 ? '#f1c21b' : '#fa4d56') +
      ';font-size:1.25rem;font-weight:600">' + rate + '%</span>';
  }
}

function renderToolChart(topTools) {
  const container = document.getElementById('toolChart');
  destroyChart('tools');
  container.innerHTML = '';

  if (!topTools || topTools.length === 0) {
    container.innerHTML = '<p class="empty-state">No tool calls yet</p>';
    return;
  }

  try {
    const chartData = topTools.map(t => ({ group: t.tool_name, value: t.calls }));
    const chartHeight = Math.max(200, topTools.length * 28 + 60) + 'px';
    const chart = new Charts.SimpleBarChart(container, {
      data: chartData,
      options: {
        theme: 'g100',
        resizable: true,
        height: chartHeight,
        bars: {
          orientation: 'horizontal',
          maxWidth: 12,
          spacingInner: 0.3
        },
        axes: {
          left: {
            mapsTo: 'group',
            scaleType: 'labels',
            truncation: {
              type: 'mid_line',
              threshold: 20
            }
          },
          bottom: {
            mapsTo: 'value'
          }
        },
        legend: { enabled: false },
        toolbar: { enabled: false },
        color: {
          scale: { [chartData[0]?.group]: '#6366f1' }
        }
      }
    });
    chartInstances.set('tools', chart);
  } catch (e) {
    // Fallback to simple CSS bars
    const max = topTools[0].calls;
    container.innerHTML = topTools.map(t =>
      '<div style="display:flex;align-items:center;gap:.75rem;margin-bottom:.4rem">' +
        '<span style="width:200px;font-size:.8rem;color:#c6c6c6;text-align:right;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;flex-shrink:0">' + t.tool_name + '</span>' +
        '<div style="flex:1;background:#262626;border-radius:4px;height:20px;overflow:hidden">' +
          '<div style="height:100%;background:#6366f1;border-radius:4px;width:' + Math.max(2, (t.calls / max) * 100) + '%"></div>' +
        '</div>' +
        '<span style="width:50px;font-size:.8rem;color:#8d8d8d">' + t.calls + '</span>' +
      '</div>'
    ).join('');
  }
}

function renderSourceChart(sourceBreakdown) {
  const container = document.getElementById('sourceChart');
  destroyChart('source');
  container.innerHTML = '';

  if (!sourceBreakdown || sourceBreakdown.length === 0) {
    container.innerHTML = '<p class="empty-state">No data</p>';
    return;
  }

  try {
    const chartData = sourceBreakdown.map(s => ({ group: s.source_id, value: s.calls }));
    const chart = new Charts.DonutChart(container, {
      data: chartData,
      options: {
        theme: 'g100',
        resizable: true,
        height: '250px',
        donut: {
          center: {
            label: 'Calls'
          }
        },
        legend: {
          alignment: 'center',
          position: 'bottom'
        },
        toolbar: { enabled: false }
      }
    });
    chartInstances.set('source', chart);
  } catch (e) {
    // Fallback to tag chips
    container.innerHTML = '<div style="display:flex;flex-wrap:wrap;gap:.5rem">' +
      sourceBreakdown.map(s =>
        '<cds-tag type="gray">' + s.source_id + ' (' + s.calls + ')</cds-tag>'
      ).join('') + '</div>';
  }
}

function renderSourceTokenChart(sourceBreakdown) {
  const container = document.getElementById('sourceTokenChart');
  destroyChart('sourceToken');
  container.innerHTML = '';

  if (!sourceBreakdown || sourceBreakdown.length === 0) {
    container.innerHTML = '<p class="empty-state">No data</p>';
    return;
  }

  try {
    const chartData = [];
    sourceBreakdown.forEach(s => {
      chartData.push({ group: 'Calls', key: s.source_id, value: s.calls });
      chartData.push({ group: 'Tokens (K)', key: s.source_id, value: Math.round((s.tokens || 0) / 1000) });
    });

    // Scale height to source count so bars don't overlap
    const chartHeight = Math.max(200, sourceBreakdown.length * 60 + 80) + 'px';

    const chart = new Charts.GroupedBarChart(container, {
      data: chartData,
      options: {
        theme: 'g100',
        resizable: true,
        height: chartHeight,
        bars: {
          orientation: 'horizontal',
          maxWidth: 12,
          spacingInner: 0.3
        },
        axes: {
          left: {
            mapsTo: 'key',
            scaleType: 'labels'
          },
          bottom: {
            mapsTo: 'value'
          }
        },
        legend: {
          alignment: 'center',
          position: 'bottom'
        },
        toolbar: { enabled: false },
        color: {
          scale: {
            'Calls': '#6366f1',
            'Tokens (K)': '#f97316'
          }
        }
      }
    });
    chartInstances.set('sourceToken', chart);
  } catch (e) {
    // Fallback: simple HTML table
    container.innerHTML = '<table style="width:100%;border-collapse:collapse;font-size:.85rem;color:#c6c6c6">' +
      '<thead><tr>' +
        '<th style="text-align:left;padding:.5rem;border-bottom:1px solid #393939">Source</th>' +
        '<th style="text-align:right;padding:.5rem;border-bottom:1px solid #393939">Calls</th>' +
        '<th style="text-align:right;padding:.5rem;border-bottom:1px solid #393939">Tokens</th>' +
      '</tr></thead><tbody>' +
      sourceBreakdown.map(s =>
        '<tr>' +
          '<td style="padding:.35rem .5rem">' + s.source_id + '</td>' +
          '<td style="text-align:right;padding:.35rem .5rem">' + fmt(s.calls) + '</td>' +
          '<td style="text-align:right;padding:.35rem .5rem">' + fmt(s.tokens || 0) + '</td>' +
        '</tr>'
      ).join('') +
      '</tbody></table>';
  }
}

async function loadHealth() {
  const data = await fetchJson(API + '/health');
  const container = document.getElementById('adapterHealth');

  if (!data.latest || data.latest.length === 0) {
    container.innerHTML = '<p class="empty-state">No adapter data yet</p>';
    return;
  }

  container.innerHTML = data.latest.map((a, i) => {
    const sparkId = 'spark-' + i;
    return '<cds-tile class="adapter-tile">' +
      '<div class="adapter-header">' +
        '<span class="status-dot ' + a.status + '"></span>' +
        '<span class="adapter-name">' + a.adapter_id + '</span>' +
        '<cds-tag type="' + (a.status === 'up' ? 'green' : 'red') + '" size="sm">' + a.status + '</cds-tag>' +
      '</div>' +
      '<div class="adapter-meta">' +
        (a.tool_count != null ? a.tool_count + ' tools' : '') +
        (a.resource_count != null ? ' &middot; ' + a.resource_count + ' resources' : '') +
        ' &middot; ' + a.init_duration_ms + 'ms init' +
      '</div>' +
      (a.error_message ? '<div class="adapter-error">' + a.error_message + '</div>' : '') +
      '<div class="adapter-meta">' + relTime(a.checked_at) + '</div>' +
      '<div class="chart-container-small" id="' + sparkId + '"></div>' +
    '</cds-tile>';
  }).join('');

  // Render sparklines if history data exists
  if (data.history) {
    data.latest.forEach((a, i) => {
      const history = data.history[a.adapter_id];
      if (history && history.length > 1) {
        renderSparkline('spark-' + i, history);
      }
    });
  }
}

function renderSparkline(containerId, history) {
  const container = document.getElementById(containerId);
  if (!container) return;
  const key = 'spark-' + containerId;
  destroyChart(key);

  try {
    const chartData = history.map(h => ({
      group: 'status',
      date: new Date(h.checked_at + 'Z'),
      value: h.status === 'up' ? 1 : 0
    }));

    const chart = new Charts.LineChart(container, {
      data: chartData,
      options: {
        theme: 'g100',
        resizable: true,
        height: '48px',
        axes: {
          bottom: { visible: false, mapsTo: 'date', scaleType: 'time' },
          left: { visible: false, mapsTo: 'value' }
        },
        grid: { x: { enabled: false }, y: { enabled: false } },
        legend: { enabled: false },
        toolbar: { enabled: false },
        points: { enabled: false },
        color: {
          scale: { status: '#42be65' }
        }
      }
    });
    chartInstances.set(key, chart);
  } catch (e) {
    // Sparkline failed silently — no fallback needed
  }
}

async function loadRecent() {
  const data = await fetchJson(API + '/tools?period=' + period + '&limit=50');
  const tbody = document.getElementById('recentCalls');

  if (!data.data || data.data.length === 0) {
    tbody.innerHTML = '<cds-table-row><cds-table-cell colspan="6"><span class="empty-state">No tool calls yet</span></cds-table-cell></cds-table-row>';
    return;
  }

  tbody.innerHTML = data.data.map(r =>
    '<cds-table-row>' +
      '<cds-table-cell>' + r.tool_name + '</cds-table-cell>' +
      '<cds-table-cell>' + (r.source_id || '\u2014') + '</cds-table-cell>' +
      '<cds-table-cell><cds-tag type="' + (r.status === 'success' ? 'green' : 'red') + '" size="sm">' + r.status + '</cds-tag></cds-table-cell>' +
      '<cds-table-cell>' + (r.duration_ms != null ? r.duration_ms + 'ms' : '\u2014') + '</cds-table-cell>' +
      '<cds-table-cell>' + fmt(r.token_estimate) + '</cds-table-cell>' +
      '<cds-table-cell>' + relTime(r.called_at) + '</cds-table-cell>' +
    '</cds-table-row>'
  ).join('');
}

async function loadSessions() {
  const data = await fetchJson(API + '/sessions');
  const badge = document.getElementById('sessions');
  badge.textContent = data.active + ' session' + (data.active !== 1 ? 's' : '');
}

async function refresh() {
  try {
    await Promise.all([loadStats(), loadHealth(), loadRecent(), loadSessions()]);
  } catch (err) {
    console.error('Dashboard refresh error:', err);
  }
}

// Period dropdown
document.getElementById('periodSelect').addEventListener('cds-dropdown-selected', (e) => {
  const item = e.detail?.item;
  if (item) {
    period = item.getAttribute('value') || '7d';
    destroyAllCharts();
    refresh();
  }
});

let refreshTimer = null;

function startPolling() {
  if (refreshTimer) return;
  refreshTimer = setInterval(refresh, 30000);
}

function stopPolling() {
  if (refreshTimer) {
    clearInterval(refreshTimer);
    refreshTimer = null;
  }
}

document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    stopPolling();
  } else {
    // Replace chart containers with fresh DOM nodes to clear any
    // residual state (ResizeObservers, inline styles) from hidden tab
    ['successGauge', 'toolChart', 'sourceChart', 'sourceTokenChart'].forEach(freshContainer);
    chartInstances.clear();
    refresh();
    startPolling();
  }
});

refresh();
startPolling();
</script>
</body>
</html>
